<!DOCTYPE html>
<html lang="en-US">

<head>
    <meta charset="UTF-8">
    <title>jiMUD</title>
    <link href="css/main.css" rel="stylesheet" type="text/css" />
    <link href="../lib/font-awesome.min.css" rel="stylesheet" type="text/css" />
    <link href="css/theme.css" rel="stylesheet" type="text/css" />
    <link href="css/cm.css" rel="stylesheet" type="text/css" />
    <link href="../lib/bootstrap.min.css" rel="stylesheet" type="text/css" />
    <link href="../lib/bootstrap-theme.min.css" rel="stylesheet" type="text/css" />
    <link id="theme" rel="stylesheet" href="themes/default.css" type="text/css" />
    <script type="text/javascript">
        if (typeof module === 'object') { window.module = module; module = undefined; }
    </script>
    <script src="../lib/jquery.min.js"></script>
    <script src="../lib/bootstrap.min.js"></script>
    <script type="text/javascript">
        const { ipcRenderer } = require('electron');
        const { parseTemplate, isFileSync } = require('./js/library.js');
        const { TabStrip } = require('./js/tabstrip.js');
        const clients = [];
        var _id;
        var tabStrip;
        var current = 0;

        function loadTheme(theme, force) {
            theme = parseTemplate(theme) + '.css';
            if (!isFileSync(theme))
                theme = parseTemplate(path.join('{themes}', 'default')) + '.css';
            var el = document.getElementById('theme');
            if (el.getAttribute('href') !== theme || force)
                el.setAttribute('href', theme);
        }

        $(document).ready(() => {
            tabstrip = new TabStrip();
            //tabstrip.hideTabstrip = false;
            tabstrip.useNativeMenus = true;
            tabstrip.on('tab-strip-hidden', () => {
                ipcRenderer.send('update-client', current, 0);
            });
            tabstrip.on('tab-strip-shown', () => {
                ipcRenderer.send('update-client', current, tabstrip.height);
            });
            tabstrip.on('add', e => {
                if (tabstrip.tabs.length === 2) {
                    //force a refresh as will not update while hidden
                    tabstrip.refresh();
                    //resize previous tab just to ensure all are same size
                    ipcRenderer.send('update-client', tabstrip.tabs[0].client, tabstrip.height);
                    ipcRenderer.send('update-client', current, tabstrip.height);
                }
            });
            tabstrip.on('tab-click', e => {
                ipcRenderer.send('switch-client', e.tab.client, tabstrip.height);
                current = e.tab.client;
            });
            tabstrip.on('remove', e => {
                ipcRenderer.send('remove-client', e.tab.client);
                //cancel the remove as we want to make sure it is called after browser view is cleaned up as it may cancel based on user input
                e.cancel = true;
            });
            tabstrip.on('removed', tab => {
                if (tabstrip.tabs.length === 1) {
                    ipcRenderer.send('update-client', current, 0);
                }
            });
            tabstrip.on('activated', e => {
                ipcRenderer.send('switch-client', e.tab.client, tabstrip.height);
                current = e.tab.client;
            })
            tabstrip.on('tab-moved', e => {
                ipcRenderer.send('reorder-client', e.tab.client, e.index, e.oldIndex);
            });
            tabstrip.on('tab-drag', e => {
                console.log('tab drag');
                console.log(e)
            });
            tabstrip.on('tab-drag-over', e => {
                console.log('tab over');
                console.log(e)
            });
            tabstrip.on('tab-drag-end', e => {
                console.log('tab end');
                console.log(e)
                //dropped outside of client area so new window if more then 1 tab
                if (e.event.dataTransfer.dropEffect !== 'move' && (e.event.clientX < 0 || e.event.clientY < 0 || e.event.clientX >= document.body.clientHeight || e.event.clientY >= document.body.clientWidth)) {
                    e.event.stopPropagation();
                    e.event.preventDefault();
                    ipcRenderer.send('dock-client', tabstrip.dragTab.client, { x: e.event.screenX, y: e.event.screenY });
                    //ipcRenderer.send('dock-client', tabstrip.dragTab.client, { x: e.event.screenX - e.event.clientX, y: e.event.screenY - e.event.clientY });
                }
            });
            tabstrip.on('tab-drag-leave', e => {
                console.log('tab leave');
                console.log(e)
            });
            tabstrip.on('tab-drop', e => {
                console.log('tab drop');
                console.log(e)
                //if not dragging its from a different window so its a undock/dock
                if (!tabstrip.dragTab) {
                    e.preventDefault = true;
                    e.event.stopPropagation();
                    e.event.preventDefault();
                    console.log(e.event.dataTransfer.getData('jimud/tab'));
                    const tab = JSON.parse(e.event.dataTransfer.getData('jimud/tab'));
                    e.tab.tab.classList.remove('drop');
                    ipcRenderer.send('dock-client', tab.client, { index: tabstrip.getTabIndex(e.tab) });
                }
            });

            window.addEventListener('dragstart', (e) => {
                if (e.dataTransfer.types && e.dataTransfer.types.indexOf('jimud/tab') !== -1) {
                    e.dataTransfer.dropEffect = 'move';
                    console.log('Window start');
                    console.log(e)
                }
            });
            window.addEventListener('dragleave', (e) => {
                if (e.dataTransfer.types && e.dataTransfer.types.indexOf('jimud/tab') !== -1) {
                    e.dataTransfer.dropEffect = 'move';
                    console.log('Window leave');
                    console.log(e)
                    e.preventDefault();
                    e.stopPropagation();
                }
            });
            window.addEventListener('dragover', (e) => {
                if (e.dataTransfer.types && e.dataTransfer.types.indexOf('jimud/tab') !== -1) {
                    e.dataTransfer.dropEffect = 'move';
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Window over');
                    console.log(e)
                }
            });
            window.addEventListener('dragenter', (e) => {
                if (e.dataTransfer.types && e.dataTransfer.types.indexOf('jimud/tab') !== -1) {
                    e.dataTransfer.dropEffect = 'move';
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Window eneter');
                    console.log(e)
                }
            });
            window.addEventListener('dragend', (e) => {
                if (e.dataTransfer.types && e.dataTransfer.types.indexOf('jimud/tab') !== -1) {
                    e.dataTransfer.dropEffect = 'move';
                    console.log('Window end');
                    console.log(e)
                }
            });
            window.addEventListener('drop', (e) => {
                if (e.dataTransfer.types && e.dataTransfer.types.indexOf('jimud/tab') !== -1) {
                    e.dataTransfer.dropEffect = 'move';
                    e.stopPropagation();
                    e.preventDefault();
                    console.log('Window drop');
                    console.log(e);
                    const tab = JSON.parse(e.dataTransfer.getData('jimud/tab'));
                    ipcRenderer.send('dock-client', tab.client, { x: e.screenX, y: e.screenY });
                    //ipcRenderer.send('dock-client', tab.client, { x: e.screenX - e.clientX, y: e.screenY - e.clientY });
                }
            });

            if (clients.length) {
                for (var c = 0, cl = clients.length; c < cl; c++)
                    addClient(clients[c]);
                if (current)
                    switchToClient(current);
            }
        });
        /*
                window.onbeforeunload = function (evt) {
                    const close = ipcRenderer.sendSync('can-close-all-client');
                    console.log(close);
                    if (!close) {
                        evt.returnValue = false;
                        return 'no';
                    }
                };
                */

        function getActiveClient() {
            return current;
        }

        function setId(id) {
            _id = id;
        }

        function getId() {
            return _id;
        }

        ipcRenderer.on('new-client', (event, id, index) => {
            if (typeof index !== 'undefined' && index !== -1 && index < clients.length)
                clients.splice(index, 0, id);
            else
                clients.push(id);
            if (typeof tabstrip !== 'undefined')
                addClient(id, index);
        });

        ipcRenderer.on('switch-client', (event, id) => {
            current = id;
            if (typeof tabstrip !== 'undefined')
                switchToClient(id);
        });

        ipcRenderer.on('removed-client', (event, id) => {
            const idx = clients.indexOf(id);
            if (idx !== -1)
                clients.splice(idx, 1);
            for (var t = 0, tl = tabstrip.tabs.length; t < tl; t++) {
                if (tabstrip.tabs[t].client === id) {
                    //remove the tab with out events or you get a loop
                    tabstrip.removeTab(t, true);
                    break;
                }
            }
        });

        function addClient(id, index) {
            let tab;
            if (typeof index !== 'undefined' && index !== -1 && index < clients.length)
                tab = tabstrip.insertTab(index, '' + id, 'disconnected-icon');
            else
                tab = tabstrip.addTab('' + id, 'disconnected-icon');
            tab.client = id;
            current = id;
            ipcRenderer.send('update-client', id, tabstrip.height);
        }

        function switchToClient(id) {
            for (var t = 0, tl = tabstrip.tabs.length; t < tl; t++) {
                if (tabstrip.tabs[t].client === id) {
                    tabstrip.switchToTabByIndex(t);
                    break;
                }
            }
        }

        function switchTab(index) {
            tabstrip.switchToTabByIndex(index);
        }        
    </script>
    <style>
        body {
            /*@TODO temp fix until tabs support theming to prevent black to white flicking*/
            background-color: rgb(255, 255, 255);
        }

        /*use circle icons to see better, maybe add a setting to allow user choice*/
        .connected-icon {
            background-image: url(../assets/icons/png/connected.png);
        }

        .connectednonactive-icon {
            background-image: url(../assets/icons/png/connectednonactive.png);
        }

        .disconnected-icon {
            background-image: url(../assets/icons/png/disconnected.png);
        }

        .text-connected-icon {
            color: blue;
        }

        .text-connectednonactive-icon {
            color: lime;
        }

        .text-disconnected-icon {
            color: red;
        }
    </style>
</head>

<body id="client-container">
</body>

</html>