<!DOCTYPE html>
<html lang="en-US">

<head>
    <meta charset="UTF-8">
    <title>jiMUD</title>
    <link href="css/main.css" rel="stylesheet" type="text/css" />
    <link href="../lib/font-awesome.min.css" rel="stylesheet" type="text/css" />
    <link href="css/theme.css" rel="stylesheet" type="text/css" />
    <link href="css/cm.css" rel="stylesheet" type="text/css" />
    <link href="../lib/bootstrap.min.css" rel="stylesheet" type="text/css" />
    <link href="../lib/bootstrap-theme.min.css" rel="stylesheet" type="text/css" />
    <link id="theme" rel="stylesheet" href="themes/default.css" type="text/css" />
    <script type="text/javascript">
        if (typeof module === 'object') { window.module = module; module = undefined; }
    </script>
    <script src="../lib/jquery.min.js"></script>
    <script src="../lib/bootstrap.min.js"></script>
    <script type="text/javascript">
        const { ipcRenderer } = require('electron');
        const { parseTemplate, isFileSync } = require('./js/library.js');
        const { TabStrip } = require('./js/tabstrip.js');
        const clients = [];
        var _id;
        var tabStrip;
        var current = 0;

        /*
        function dockClient(id) {
            if (clients.indexOf(id) !== -1) return;
            ipcRenderer.send('dock-client', id, 32);
            current = id;
            ipcRenderer.send('switch-client', current, 32);
            tabStrip.appendChild(createTab(id));
            if (tabStrip.childNodes.length < 2)
                tabStrip.style.display = 'none';
            else
                tabStrip.style.display = 'inline-block';
            clients.push(id);
        }

        function undockClient(id) {
            var idx = clients.indexOf(id);
            if (clients.indexOf(id) === -1) return;
            ipcRenderer.send('undock-client', id);
            removeTab(id);
            clients.splice(idx, 1);
            if (tabStrip.childNodes.length < 2)
                tabStrip.style.display = 'none';
            else
                tabStrip.style.display = 'inline-block';
            if (id === current) {
                if (idx >= clients.length)
                    idx = clients.length - 1;
                current = clients[idx];
                ipcRenderer.send('switch-client', current, tabStrip.childNodes.length === 1 ? 0 : 32);
            }
            else
                ipcRenderer.send('update-client', current, tabStrip.childNodes.length === 1 ? 0 : 32);
        }
        */

        function loadTheme(theme, force) {
            theme = parseTemplate(theme) + '.css';
            if (!isFileSync(theme))
                theme = parseTemplate(path.join('{themes}', 'default')) + '.css';
            var el = document.getElementById('theme');
            if (el.getAttribute('href') !== theme || force)
                el.setAttribute('href', theme);
        }

        $(document).ready(() => {
            tabstrip = new TabStrip();
            //tabstrip.hideTabstrip = false;
            tabstrip.useNativeMenus = true;
            tabstrip.on('tab-strip-hidden', () => {
                ipcRenderer.send('update-client', current, 0);
            });
            tabstrip.on('tab-strip-shown', () => {
                ipcRenderer.send('update-client', current, tabstrip.height);
            });
            tabstrip.on('add', e => {
                if (tabstrip.tabs.length === 2) {
                    //force a refresh as will not update while hidden
                    tabstrip.refresh();
                    ipcRenderer.send('update-client', current, tabstrip.height);
                }
            });
            tabstrip.on('tab-click', e => {
                ipcRenderer.send('switch-client', e.tab.client, tabstrip.height);
                current = e.tab.client;
            });
            tabstrip.on('remove', e => {
                ipcRenderer.send('remove-client', e.tab.client);
                //cancel the remove as we want to make sure it is called after browser view is cleaned up as it may cancel based on user input
                e.cancel = true;
            });
            tabstrip.on('removed', tab => {
                if (tabstrip.tabs.length === 1) {
                    ipcRenderer.send('update-client', current, 0);
                }
            });
            tabstrip.on('activated', e => {
                ipcRenderer.send('switch-client', e.tab.client, tabstrip.height);
                current = e.tab.client;
            })
            tabstrip.on('tab-moved', e=> {
                ipcRenderer.send('reorder-client', e.tab.client, e.index, e.oldIndex);
            });
            tabstrip.on('tab-drag', e => {
                console.log('tab drag');
                console.log(e)
            });
            tabstrip.on('tab-drag-over', e => {
                console.log('tab over');
                console.log(e)
            });
            tabstrip.on('tab-drag-end', e => {
                console.log('tab end');
                console.log(e)
            });
            tabstrip.on('tab-drag-leave', e => {
                console.log('tab leave');
                console.log(e)
            });
            tabstrip.on('tab-drop', e => {
                console.log('tab drop');
                console.log(e)
            });
            /*
            window.addEventListener('dragstart', (e) => {
                e.dataTransfer.dropEffect = 'move';
                console.log('Window start');
                console.log(e)
            });
            window.addEventListener('dragleave', (e) => {
                e.dataTransfer.dropEffect = 'move';
                console.log('Window leave');
                console.log(e)
                e.preventDefault();
                e.stopPropagation();                
            });            
            window.addEventListener('dragover', (e) => {
                e.dataTransfer.dropEffect = 'move';
                e.preventDefault();
                e.stopPropagation();
                console.log('Window over');
                console.log(e)
            });   
            window.addEventListener('dragenter', (e) => {
                e.dataTransfer.dropEffect = 'move';
                e.preventDefault();
                e.stopPropagation();
                console.log('Window eneter');
                console.log(e)
            });              
            window.addEventListener('dragend', (e) => {
                e.dataTransfer.dropEffect = 'move';
                console.log('Window end');
                console.log(e)
            });    
            window.addEventListener('drop', (e) => {
                e.dataTransfer.dropEffect = 'move';
                console.log('Window drop');
                console.log(e)
            });  
            */
            if (clients.length) {
                for (var c = 0, cl = clients.length; c < cl; c++)
                    addClient(clients[c]);
                if (current)
                    switchToClient(current);
            }
        });

        window.onbeforeunload = function (evt) {
            if (!ipcRenderer.sendSync('can-close-all-client')) {
                evt.returnValue = false;
                return 'no';
            }           
        };

        function getActiveClient() {
            return current;
        }

        function setId(id) {
            _id = id;
        }

        function getId() {
            return _id;
        }

        ipcRenderer.on('new-client', (event, id) => {
            clients.push(id);
            if (typeof tabstrip !== 'undefined')
                addClient(id);
        });

        ipcRenderer.on('switch-client', (event, id) => {
            current = id;
            if (typeof tabstrip !== 'undefined')
                switchToClient(id);
        });

        ipcRenderer.on('removed-client', (event, id) => {
            for (var t = 0, tl = tabstrip.tabs.length; t < tl; t++) {
                if (tabstrip.tabs[t].client === id) {
                    //remove the tab with out events or you get a loop
                    tabstrip.removeTab(t, true);
                    break;
                }
            }
        });

        function addClient(id) {
            let tab = tabstrip.addTab('' + id, 'disconnected-icon');
            tab.client = id;
            current = id;
            ipcRenderer.send('update-client', id, tabstrip.height);
        }

        function switchToClient(id) {
            for (var t = 0, tl = tabstrip.tabs.length; t < tl; t++) {
                if (tabstrip.tabs[t].client === id) {
                    tabstrip.switchToTabByIndex(t);
                    break;
                }
            }
        }

        function switchTab(index) {
            tabstrip.switchToTabByIndex(index);
        }        
    </script>
    <style>
        body {
            /*@TODO temp fix until tabs support theming to prevent black to white flicking*/
            background-color: rgb(255, 255, 255);
        }

        /*use circle icons to see better, maybe add a setting to allow user choice*/
        .connected-icon {
            background-image: url(../assets/icons/png/connected.png);
        }

        .connectednonactive-icon {
            background-image: url(../assets/icons/png/connectednonactive.png);
        }

        .disconnected-icon {
            background-image: url(../assets/icons/png/disconnected.png);
        }
    </style>
</head>

<body id="client-container">
</body>

</html>