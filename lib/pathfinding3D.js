/**
 *    ____       _   _     _____ _           _ _                _         
 *   |  _ \ __ _| |_| |__ |  ___(_)_ __   __| (_)_ __   __ _   (_)___     
 *   | |_) / _` | __| '_ \| |_  | | '_ \ / _` | | '_ \ / _` |  | / __|    
 *   |  __/ (_| | |_| | | |  _| | | | | | (_| | | | | | (_| |_ | \__ \    
 *   |_|   \__,_|\__|_| |_|_|   |_|_| |_|\__,_|_|_| |_|\__, (_)/ |___/    
 *                                                     |___/ |__/         
 *   https://github.com/qiao/PathFinding.js
 */
(function (e) {
    if ("function" == typeof bootstrap) bootstrap("pf", e);
    else if ("object" == typeof exports) module.exports = e();
    else if ("function" == typeof define && define.amd) define(e);
    else if ("undefined" != typeof ses) {
        if (!ses.ok()) return;
        ses.makePF = e
    }
    else "undefined" != typeof window ? window.PF = e() : global.PF = e();
})(function () {
    var define, ses, bootstrap, module, exports;
    return (function (e, t, n) { function i(n, s) { if (!t[n]) { if (!e[n]) { var o = typeof require == "function" && require; if (!s && o) return o(n, !0); if (r) return r(n, !0); throw new Error("Cannot find module '" + n + "'") } var u = t[n] = { exports: {} }; e[n][0].call(u.exports, function (t) { var r = e[n][1][t]; return i(r ? r : t) }, u, u.exports) } return t[n].exports } var r = typeof require == "function" && require; for (var s = 0; s < n.length; s++)i(n[s]); return i })({
        1: [function (require, module, exports) {
            module.exports = require('./lib/heap');

        }, { "./lib/heap": 2 }], 2: [function (require, module, exports) {
            // Generated by CoffeeScript 1.6.3
            (function () {
                var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;

                floor = Math.floor, min = Math.min;

                /* 
                Default comparison function to be used
                */


                defaultCmp = function (x, y) {
                    if (x < y) {
                        return -1;
                    }
                    if (x > y) {
                        return 1;
                    }
                    return 0;
                };

                /* 
                Insert item x in list a, and keep it sorted assuming a is sorted.
                
                If x is already in a, insert it to the right of the rightmost x.
                
                Optional args lo (default 0) and hi (default a.length) bound the slice
                of a to be searched.
                */


                insort = function (a, x, lo, hi, cmp) {
                    var mid;
                    if (lo == null) {
                        lo = 0;
                    }
                    if (cmp == null) {
                        cmp = defaultCmp;
                    }
                    if (lo < 0) {
                        throw new Error('lo must be non-negative');
                    }
                    if (hi == null) {
                        hi = a.length;
                    }
                    while (lo < hi) {
                        mid = floor((lo + hi) / 2);
                        if (cmp(x, a[mid]) < 0) {
                            hi = mid;
                        } else {
                            lo = mid + 1;
                        }
                    }
                    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);
                };

                /*
                Push item onto heap, maintaining the heap invariant.
                */


                heappush = function (array, item, cmp) {
                    if (cmp == null) {
                        cmp = defaultCmp;
                    }
                    array.push(item);
                    return _siftdown(array, 0, array.length - 1, cmp);
                };

                /*
                Pop the smallest item off the heap, maintaining the heap invariant.
                */


                heappop = function (array, cmp) {
                    var lastelt, returnitem;
                    if (cmp == null) {
                        cmp = defaultCmp;
                    }
                    lastelt = array.pop();
                    if (array.length) {
                        returnitem = array[0];
                        array[0] = lastelt;
                        _siftup(array, 0, cmp);
                    } else {
                        returnitem = lastelt;
                    }
                    return returnitem;
                };

                /*
                Pop and return the current smallest value, and add the new item.
                
                This is more efficient than heappop() followed by heappush(), and can be 
                more appropriate when using a fixed size heap. Note that the value
                returned may be larger than item! That constrains reasonable use of
                this routine unless written as part of a conditional replacement:
                    if item > array[0]
                      item = heapreplace(array, item)
                */


                heapreplace = function (array, item, cmp) {
                    var returnitem;
                    if (cmp == null) {
                        cmp = defaultCmp;
                    }
                    returnitem = array[0];
                    array[0] = item;
                    _siftup(array, 0, cmp);
                    return returnitem;
                };

                /*
                Fast version of a heappush followed by a heappop.
                */


                heappushpop = function (array, item, cmp) {
                    var _ref;
                    if (cmp == null) {
                        cmp = defaultCmp;
                    }
                    if (array.length && cmp(array[0], item) < 0) {
                        _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
                        _siftup(array, 0, cmp);
                    }
                    return item;
                };

                /*
                Transform list into a heap, in-place, in O(array.length) time.
                */


                heapify = function (array, cmp) {
                    var i, _i, _j, _len, _ref, _ref1, _results, _results1;
                    if (cmp == null) {
                        cmp = defaultCmp;
                    }
                    _ref1 = (function () {
                        _results1 = [];
                        for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--) { _results1.push(_j); }
                        return _results1;
                    }).apply(this).reverse();
                    _results = [];
                    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                        i = _ref1[_i];
                        _results.push(_siftup(array, i, cmp));
                    }
                    return _results;
                };

                /*
                Update the position of the given item in the heap.
                This function should be called every time the item is being modified.
                */


                updateItem = function (array, item, cmp) {
                    var pos;
                    if (cmp == null) {
                        cmp = defaultCmp;
                    }
                    pos = array.indexOf(item);
                    if (pos === -1) {
                        return;
                    }
                    _siftdown(array, 0, pos, cmp);
                    return _siftup(array, pos, cmp);
                };

                /*
                Find the n largest elements in a dataset.
                */


                nlargest = function (array, n, cmp) {
                    var elem, result, _i, _len, _ref;
                    if (cmp == null) {
                        cmp = defaultCmp;
                    }
                    result = array.slice(0, n);
                    if (!result.length) {
                        return result;
                    }
                    heapify(result, cmp);
                    _ref = array.slice(n);
                    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                        elem = _ref[_i];
                        heappushpop(result, elem, cmp);
                    }
                    return result.sort(cmp).reverse();
                };

                /*
                Find the n smallest elements in a dataset.
                */


                nsmallest = function (array, n, cmp) {
                    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
                    if (cmp == null) {
                        cmp = defaultCmp;
                    }
                    if (n * 10 <= array.length) {
                        result = array.slice(0, n).sort(cmp);
                        if (!result.length) {
                            return result;
                        }
                        los = result[result.length - 1];
                        _ref = array.slice(n);
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                            elem = _ref[_i];
                            if (cmp(elem, los) < 0) {
                                insort(result, elem, 0, null, cmp);
                                result.pop();
                                los = result[result.length - 1];
                            }
                        }
                        return result;
                    }
                    heapify(array, cmp);
                    _results = [];
                    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
                        _results.push(heappop(array, cmp));
                    }
                    return _results;
                };

                _siftdown = function (array, startpos, pos, cmp) {
                    var newitem, parent, parentpos;
                    if (cmp == null) {
                        cmp = defaultCmp;
                    }
                    newitem = array[pos];
                    while (pos > startpos) {
                        parentpos = (pos - 1) >> 1;
                        parent = array[parentpos];
                        if (cmp(newitem, parent) < 0) {
                            array[pos] = parent;
                            pos = parentpos;
                            continue;
                        }
                        break;
                    }
                    return array[pos] = newitem;
                };

                _siftup = function (array, pos, cmp) {
                    var childpos, endpos, newitem, rightpos, startpos;
                    if (cmp == null) {
                        cmp = defaultCmp;
                    }
                    endpos = array.length;
                    startpos = pos;
                    newitem = array[pos];
                    childpos = 2 * pos + 1;
                    while (childpos < endpos) {
                        rightpos = childpos + 1;
                        if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
                            childpos = rightpos;
                        }
                        array[pos] = array[childpos];
                        pos = childpos;
                        childpos = 2 * pos + 1;
                    }
                    array[pos] = newitem;
                    return _siftdown(array, startpos, pos, cmp);
                };

                Heap = (function () {
                    Heap.push = heappush;

                    Heap.pop = heappop;

                    Heap.replace = heapreplace;

                    Heap.pushpop = heappushpop;

                    Heap.heapify = heapify;

                    Heap.nlargest = nlargest;

                    Heap.nsmallest = nsmallest;

                    function Heap(cmp) {
                        this.cmp = cmp != null ? cmp : defaultCmp;
                        this.nodes = [];
                    }

                    Heap.prototype.push = function (x) {
                        return heappush(this.nodes, x, this.cmp);
                    };

                    Heap.prototype.pop = function () {
                        return heappop(this.nodes, this.cmp);
                    };

                    Heap.prototype.peek = function () {
                        return this.nodes[0];
                    };

                    Heap.prototype.contains = function (x) {
                        return this.nodes.indexOf(x) !== -1;
                    };

                    Heap.prototype.replace = function (x) {
                        return heapreplace(this.nodes, x, this.cmp);
                    };

                    Heap.prototype.pushpop = function (x) {
                        return heappushpop(this.nodes, x, this.cmp);
                    };

                    Heap.prototype.heapify = function () {
                        return heapify(this.nodes, this.cmp);
                    };

                    Heap.prototype.updateItem = function (x) {
                        return updateItem(this.nodes, x, this.cmp);
                    };

                    Heap.prototype.clear = function () {
                        return this.nodes = [];
                    };

                    Heap.prototype.empty = function () {
                        return this.nodes.length === 0;
                    };

                    Heap.prototype.size = function () {
                        return this.nodes.length;
                    };

                    Heap.prototype.clone = function () {
                        var heap;
                        heap = new Heap();
                        heap.nodes = this.nodes.slice(0);
                        return heap;
                    };

                    Heap.prototype.toArray = function () {
                        return this.nodes.slice(0);
                    };

                    Heap.prototype.insert = Heap.prototype.push;

                    Heap.prototype.remove = Heap.prototype.pop;

                    Heap.prototype.top = Heap.prototype.peek;

                    Heap.prototype.front = Heap.prototype.peek;

                    Heap.prototype.has = Heap.prototype.contains;

                    Heap.prototype.copy = Heap.prototype.clone;

                    return Heap;

                })();

                if (typeof module !== "undefined" && module !== null ? module.exports : void 0) {
                    module.exports = Heap;
                } else {
                    window.Heap = Heap;
                }

            }).call(this);

        }, {}], 3: [function (require, module, exports) {
            module.exports = {
                'Heap': require('heap'),
                'Node': require('./core/Node'),
                'Grid': require('./core/Grid'),
                'Util': require('./core/Util'),
                'Heuristic': require('./core/Heuristic'),
                'AStarFinder': require('./finders/AStarFinder'),
                'BestFirstFinder': require('./finders/BestFirstFinder'),
                'BreadthFirstFinder': require('./finders/BreadthFirstFinder'),
                'DijkstraFinder': require('./finders/DijkstraFinder'),
                'BiAStarFinder': require('./finders/BiAStarFinder'),
                'BiBestFirstFinder': require('./finders/BiBestFirstFinder'),
                'BiBreadthFirstFinder': require('./finders/BiBreadthFirstFinder'),
                'BiDijkstraFinder': require('./finders/BiDijkstraFinder'),
                'JumpPointFinder': require('./finders/JumpPointFinder'),
                'IDAStarFinder': require('./finders/IDAStarFinder')
            };

        }, { "./core/Grid": 4, "./core/Heuristic": 5, "./core/Node": 6, "./core/Util": 7, "./finders/AStarFinder": 8, "./finders/BestFirstFinder": 9, "./finders/BiAStarFinder": 10, "./finders/BiBestFirstFinder": 11, "./finders/BiBreadthFirstFinder": 12, "./finders/BiDijkstraFinder": 13, "./finders/BreadthFirstFinder": 14, "./finders/DijkstraFinder": 15, "./finders/IDAStarFinder": 16, "./finders/JumpPointFinder": 17, "heap": 1 }], 4: [function (require, module, exports) {
            var Node = require('./Node');

            /**
             * The Grid class, which serves as the encapsulation of the layout of the nodes.
             * @constructor
             * @param {number} width Number of columns of the grid.
             * @param {number} height Number of rows of the grid.
             * @param {Array.<Array.<(number|boolean)>>} [matrix] - A 0-1 matrix
             *     representing the walkable status of the nodes(0 or false for walkable).
             *     If the matrix is not supplied, all the nodes will be walkable.  */
            function Grid(width, height, depth, matrix) {
                /**
                 * The number of columns of the grid.
                 * @type number
                 */
                this.width = width;
                /**
                 * The number of rows of the grid.
                 * @type number
                 */
                this.height = height;

                this.depth = depth;


                /**
                 * A 2D array of nodes.
                 */
                this.nodes = this._buildNodes(width, height, depth, matrix);
            }

            /**
             * Build and return the nodes.
             * @private
             * @param {number} width
             * @param {number} height
             * @param {Array.<Array.<number|boolean>>} [matrix] - A 0-1 matrix representing
             *     the walkable status of the nodes.
             * @see Grid
             */
            Grid.prototype._buildNodes = function (width, height, depth, matrix) {
                var i, j, z,
                    nodes = new Array(height),
                    row;

                for (i = 0; i < height; ++i) {
                    nodes[i] = new Array(width);
                    for (j = 0; j < width; ++j) {
                        nodes[i][j] = new Array(depth);
                        for (z = 0; z < depth; ++z) {
                            nodes[i][j][z] = new Node(j, i, z);
                        }
                    }
                }


                if (matrix === undefined) {
                    return nodes;
                }

                if (matrix.length !== height || matrix[0].length !== width) {
                    throw new Error('Matrix size does not fit');
                }

                for (i = 0; i < height; ++i) {
                    for (j = 0; j < width; ++j) {
                        for (z = 0; z < depth; ++z) {
                            nodes[i][j][z].walkable = matrix[i][j][z];
                        }
                    }
                }

                return nodes;
            };


            Grid.prototype.getNodeAt = function (x, y, z) {
                return this.nodes[y][x][z];
            };


            /**
             * Determine whether the node at the given position is walkable.
             * (Also returns false if the position is outside the grid.)
             * @param {number} x - The x coordinate of the node.
             * @param {number} y - The y coordinate of the node.
             * @param {number} z - The z coordinate of the node.
             * @return {boolean} - The walkability of the node.
             */

            /*
               public enum RoomExits
               {
                   Unknown = 4096,    
                   Out = 2048,
                   Enter = 1024,                       
                   Up = 512,
                   Down = 256,
                   North = 128,
                   NorthEast = 64,
                   East = 32,
                   SouthEast = 16,
                   South = 8,
                   SouthWest = 4,
                   West = 2,
                   NorthWest = 1,
                   None = 0,
                   //Directional = North | NorthEast | NorthWest | South | SouthEast | SouthWest | West | East,
                   //All = Directional | Up | Down
               }
            */
            Grid.prototype.isWalkableAt = function (x, y, z, d) {
                return this.isInside(x, y, z) && (this.nodes[y][x][z].walkable & d) == d;
            };


            /**
             * Determine whether the position is inside the grid.
             * XXX: `grid.isInside(x, y, z)` is wierd to read.
             * It should be `(x, y, z) is inside grid`, but I failed to find a better
             * name for this method.
             * @param {number} x
             * @param {number} y
             * @param {number} z
             * @return {boolean}
             */
            Grid.prototype.isInside = function (x, y, z) {
                return (x >= 0 && x < this.width) && (y >= 0 && y < this.height) && (z >= 0 && z < this.depth);
            };


            /**
             * Set whether the node on the given position is walkable.
             * NOTE: throws exception if the coordinate is not inside the grid.
             * @param {number} x - The x coordinate of the node.
             * @param {number} y - The y coordinate of the node.
             * @param {number} z - The z coordinate of the node.
             * @param {boolean} walkable - Whether the position is walkable.
             */
            Grid.prototype.setWalkableAt = function (x, y, z, walkable) {
                this.nodes[y][x][z].walkable = walkable;
            };


            /**
             * Get the neighbors of the given node.
             *
             *     offsets      diagonalOffsets:
             *  +---+---+---+    +---+---+---+
             *  |   | 0 |   |    | 0 |   | 1 |
             *  +---+---+---+    +---+---+---+
             *  | 3 |   | 1 |    |   |   |   |
             *  +---+---+---+    +---+---+---+
             *  |   | 2 |   |    | 3 |   | 2 |
             *  +---+---+---+    +---+---+---+
             *
             *  When allowDiagonal is true, if offsets[i] is valid, then
             *  diagonalOffsets[i] and
             *  diagonalOffsets[(i + 1) % 4] is valid.
             * @param {Node} node
             * @param {boolean} allowDiagonal
             * @param {boolean} dontCrossCorners
             */
            Grid.prototype.getNeighbors = function (node, allowDiagonal, dontCrossCorners) {
                var x = node.x,
                    y = node.y,
                    z = node.z,
                    neighbors = [],
                    s0 = false, d0 = false,
                    s1 = false, d1 = false,
                    s2 = false, d2 = false,
                    s3 = false, d3 = false,
                    s4 = false,
                    s5 = false,
                    nodes = this.nodes;

                // ↑
                if (this.isWalkableAt(x, y, z, 128) && this.isInside(x, y - 1, z, 8)) {
                    neighbors.push(nodes[y - 1][x][z]);
                    s0 = true;
                }
                // →
                if (this.isWalkableAt(x, y, z, 32) && this.isInside(x + 1, y, z, 2)) {
                    neighbors.push(nodes[y][x + 1][z]);
                    s1 = true;
                }
                // ↓
                if (this.isWalkableAt(x, y, z, 8) && this.isInside(x, y + 1, z, 128)) {
                    neighbors.push(nodes[y + 1][x][z]);
                    s2 = true;
                }
                // ←
                if (this.isWalkableAt(x, y, z, 2) && this.isInside(x - 1, y, z, 32)) {
                    neighbors.push(nodes[y][x - 1][z]);
                    s3 = true;
                }
                //up
                if (this.isWalkableAt(x, y, z, 512) && this.isInside(x, y, z + 1, 256)) {
                    neighbors.push(nodes[y][x][z + 1]);
                    s4 = true;
                }
                //down
                if (this.isWalkableAt(x, y, z, 256) && this.isInside(x, y, z - 1, 512)) {
                    neighbors.push(nodes[y][x][z - 1]);
                    s5 = true;
                }


                if (!allowDiagonal) {
                    return neighbors;
                }

                if (dontCrossCorners) {
                    d0 = s3 && s0;
                    d1 = s0 && s1;
                    d2 = s1 && s2;
                    d3 = s2 && s3;
                } else {
                    d0 = s3 || s0 || true;
                    d1 = s0 || s1 || true;
                    d2 = s1 || s2 || true;
                    d3 = s2 || s3 || true;
                }

                // ↖ nw
                if (d0 && this.isWalkableAt(x, y, z, 1) && this.isInside(x - 1, y - 1, z, 16)) {
                    neighbors.push(nodes[y - 1][x - 1][z]);
                }
                // ↗ ne
                if (d1 && this.isWalkableAt(x, y, z, 64) && this.isInside(x + 1, y - 1, z, 4)) {
                    neighbors.push(nodes[y - 1][x + 1][z]);
                }
                // ↘ se
                if (d2 && this.isWalkableAt(x, y, z, 16) && this.isInside(x + 1, y + 1, z, 1)) {
                    neighbors.push(nodes[y + 1][x + 1][z]);
                }
                // ↙ sw
                if (d3 && this.isWalkableAt(x, y, z, 4) && this.isInside(x - 1, y + 1, z, 64)) {
                    neighbors.push(nodes[y + 1][x - 1][z]);
                }

                return neighbors;
            };


            /**
             * Get a clone of this grid.
             * @return {Grid} Cloned grid.
             */
            Grid.prototype.clone = function () {
                var i, j,

                    width = this.width,
                    height = this.height,
                    depth = this.depth,
                    thisNodes = this.nodes,

                    newGrid = new Grid(width, height, depth),
                    newNodes = new Array(height),
                    row;

                for (i = 0; i < height; ++i) {
                    newNodes[i] = new Array(width);
                    for (j = 0; j < width; ++j) {
                        newNodes[i][j] = new Array(depth);
                        for (z = 0; z < depth; ++z) {
                            newNodes[i][j][z] = new Node(j, i, z, thisNodes[i][j][z].walkable);
                        }
                    }
                }

                newGrid.nodes = newNodes;

                return newGrid;
            };

            module.exports = Grid;

        }, { "./Node": 6 }], 5: [function (require, module, exports) {
            /**
             * @namespace PF.Heuristic
             * @description A collection of heuristic functions.
             */
            module.exports = {

                /**
                 * Manhattan distance.
                 * @param {number} dx - Difference in x.
                 * @param {number} dy - Difference in y.
                 * @return {number} dx + dy
                 */
                manhattan: function (dx, dy, dz) {
                    return dx + dy + dz;
                },

                /**
                 * Euclidean distance.
                 * @param {number} dx - Difference in x.
                 * @param {number} dy - Difference in y.
                 * @return {number} sqrt(dx * dx + dy * dy)
                 */
                euclidean: function (dx, dy, dz) {
                    return Math.sqrt(dx * dx + dy * dy + dz * dz);
                },

                /**
                 * Chebyshev distance.
                 * @param {number} dx - Difference in x.
                 * @param {number} dy - Difference in y.
                 * @return {number} max(dx, dy)
                 */
                chebyshev: function (dx, dy, dz) {
                    return Math.max(dx, dy, dz);
                }

            };

        }, {}], 6: [function (require, module, exports) {
            /**
             * A node in grid. 
             * This class holds some basic information about a node and custom 
             * attributes may be added, depending on the algorithms' needs.
             * @constructor
             * @param {number} x - The x coordinate of the node on the grid.
             * @param {number} y - The y coordinate of the node on the grid.
             * @param {boolean} [walkable] - Whether this node is walkable.
             */
            function Node(x, y, z, walkable) {
                /**
                 * The x coordinate of the node on the grid.
                 * @type number
                 */
                this.x = x;
                /**
                 * The y coordinate of the node on the grid.
                 * @type number
                 */
                this.y = y;
                /**
                 * Whether this node can be walked through.
                 * @type boolean
                 */
                this.walkable = (walkable === undefined ? true : walkable);

                this.z = z;
            }

            module.exports = Node;

        }, {}], 7: [function (require, module, exports) {
            /**
             * Backtrace according to the parent records and return the path.
             * (including both start and end nodes)
             * @param {Node} node End node
             * @return {Array.<Array.<number>>} the path
             */
            function backtrace(node) {
                var path = [[node.x, node.y, node.z]];
                while (node.parent) {
                    node = node.parent;
                    path.push([node.x, node.y, node.z]);
                }
                return path.reverse();
            }
            exports.backtrace = backtrace;

            /**
             * Backtrace from start and end node, and return the path.
             * (including both start and end nodes)
             * @param {Node}
             * @param {Node}
             */
            function biBacktrace(nodeA, nodeB) {
                var pathA = backtrace(nodeA),
                    pathB = backtrace(nodeB);
                return pathA.concat(pathB.reverse());
            }
            exports.biBacktrace = biBacktrace;

            /**
             * Compute the length of the path.
             * @param {Array.<Array.<number>>} path The path
             * @return {number} The length of the path
             */
            function pathLength(path) {
                var i, sum = 0, a, b, dx, dy, dz;
                for (i = 1; i < path.length; ++i) {
                    a = path[i - 1];
                    b = path[i];
                    dx = a[0] - b[0];
                    dy = a[1] - b[1];
                    dz = a[2] - b[2];
                    sum += Math.sqrt(dx * dx + dy * dy + dz * dz);
                }
                return sum;
            }
            exports.pathLength = pathLength;


            /**
             * Given the start and end coordinates, return all the coordinates lying
             * on the line formed by these coordinates, based on Bresenham's algorithm.
             * http://en.wikipedia.org/wiki/Bresenham's_line_algorithm#Simplification
             * https://www.geeksforgeeks.org/bresenhams-algorithm-for-3-d-line-drawing/
             * @param {number} x1 Start x coordinate
             * @param {number} y1 Start y coordinate
             * @param {number} z1 Start z coordinate
             * @param {number} x2 End x coordinate
             * @param {number} y2 End y coordinate
             * @param {number} z2 End z coordinate
             * @return {Array.<Array.<number>>} The coordinates on the line
             */
            function getLine(x1, y1, z1, x2, y2, z2) {
                let ListOfPoints = [];
                ListOfPoints.push([x1, y1, z1]);
                let dx = Math.abs(x2 - x1);
                let dy = Math.abs(y2 - y1);
                let dz = Math.abs(z2 - z1);
                let xs;
                let ys;
                let zs;
                if (x2 > x1) {
                    xs = 1;
                } else {
                    xs = -1;
                }
                if (y2 > y1) {
                    ys = 1;
                } else {
                    ys = -1;
                }
                if (z2 > z1) {
                    zs = 1;
                } else {
                    zs = -1;
                }

                // Driving axis is X-axis"
                if (dx >= dy && dx >= dz) {
                    let p1 = 2 * dy - dx;
                    let p2 = 2 * dz - dx;
                    while (x1 != x2) {
                        x1 += xs;
                        if (p1 >= 0) {
                            y1 += ys;
                            p1 -= 2 * dx;
                        }
                        if (p2 >= 0) {
                            z1 += zs;
                            p2 -= 2 * dx;
                        }
                        p1 += 2 * dy;
                        p2 += 2 * dz;
                        ListOfPoints.push([x1, y1, z1]);
                    }

                    // Driving axis is Y-axis"
                } else if (dy >= dx && dy >= dz) {
                    let p1 = 2 * dx - dy;
                    let p2 = 2 * dz - dy;
                    while (y1 != y2) {
                        y1 += ys;
                        if (p1 >= 0) {
                            x1 += xs;
                            p1 -= 2 * dy;
                        }
                        if (p2 >= 0) {
                            z1 += zs;
                            p2 -= 2 * dy;
                        }
                        p1 += 2 * dx;
                        p2 += 2 * dz;
                        ListOfPoints.push([x1, y1, z1]);
                    }

                    // Driving axis is Z-axis"
                } else {
                    let p1 = 2 * dy - dz;
                    let p2 = 2 * dx - dz;
                    while (z1 != z2) {
                        z1 += zs;
                        if (p1 >= 0) {
                            y1 += ys;
                            p1 -= 2 * dz;
                        }
                        if (p2 >= 0) {
                            x1 += xs;
                            p2 -= 2 * dz;
                        }
                        p1 += 2 * dy;
                        p2 += 2 * dx;
                        ListOfPoints.push([x1, y1, z1]);
                    }
                }
                return ListOfPoints;
            }
            exports.getLine = getLine;


            /**
             * Smoothen the give path.
             * The original path will not be modified; a new path will be returned.
             * @param {PF.Grid} grid
             * @param {Array.<Array.<number>>} path The path
             * @return {Array.<Array.<number>>} Smoothened path
             */
            function smoothenPath(grid, path) {
                var len = path.length,
                    x0 = path[0][0],        // path start x
                    y0 = path[0][1],        // path start y
                    z0 = path[0][2],
                    x1 = path[len - 1][0],  // path end x
                    y1 = path[len - 1][1],  // path end y
                    z1 = path[len - 1][2],
                    sx, sy, sz                 // current start coordinate
                ex, ey, ez                // current end coordinate
                lx, ly, lz                 // last valid end coordinate
                newPath,
                    i, j, coord, line, testCoord, blocked;

                sx = x0;
                sy = y0;
                sz = z0
                lx = path[1][0];
                ly = path[1][1];
                lz = path[1][2];
                newPath = [[sx, sy, sz]];

                for (i = 2; i < len; ++i) {
                    coord = path[i];
                    ex = coord[0];
                    ey = coord[1];
                    ez = coord[2];
                    line = getLine(sx, sy, sz, ex, ey, ez);

                    blocked = false;
                    for (j = 1; j < line.length; ++j) {

                        testCoord = line[j];

                        if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {
                            blocked = true;
                            newPath.push([lx, ly]);
                            sx = lx;
                            sy = ly;
                            break;
                        }
                    }
                    if (!blocked) {
                        lx = ex;
                        ly = ey;
                    }
                }
                newPath.push([x1, y1]);

                return newPath;
            }
            exports.smoothenPath = smoothenPath;

        }, {}], 8: [function (require, module, exports) {
            var Heap = require('heap');
            var Util = require('../core/Util');
            var Heuristic = require('../core/Heuristic');

            /**
             * A* path-finder.
             * based upon https://github.com/bgrins/javascript-astar
             * @constructor
             * @param {object} opt
             * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
             * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners.
             * @param {function} opt.heuristic Heuristic function to estimate the distance
             *     (defaults to manhattan).
             * @param {integer} opt.weight Weight to apply to the heuristic to allow for suboptimal paths, 
             *     in order to speed up the search.
             */
            function AStarFinder(opt) {
                opt = opt || {};
                this.allowDiagonal = opt.allowDiagonal;
                this.dontCrossCorners = opt.dontCrossCorners;
                this.heuristic = opt.heuristic || Heuristic.manhattan;
                this.weight = opt.weight || 1;
            }

            /**
             * Find and return the the path.
             * @return {Array.<[number, number]>} The path, including both start and
             *     end positions.
             */
            AStarFinder.prototype.findPath = function (startX, startY, startZ, endX, endY, endZ, grid) {
                //if start or end are not in grid return;
                if (!grid.isInside(startX, startY, startZ) || !grid.isInside(endX, endY, endZ))
                    return [];

                var openList = new Heap(function (nodeA, nodeB) {
                    return nodeA.f - nodeB.f;
                });
                var startNode = grid.getNodeAt(startX, startY, startZ),
                    endNode = grid.getNodeAt(endX, endY, endZ),
                    heuristic = this.heuristic,
                    allowDiagonal = this.allowDiagonal,
                    dontCrossCorners = this.dontCrossCorners,
                    weight = this.weight,
                    abs = Math.abs, SQRT2 = Math.SQRT2,
                    node, neighbors, neighbor, i, l, x, y, ng, z;



                // set the `g` and `f` value of the start node to be 0
                startNode.g = 0;
                startNode.f = 0;

                // push the start node into the open list
                openList.push(startNode);
                startNode.opened = true;

                // while the open list is not empty
                while (!openList.empty()) {
                    // pop the position of node which has the minimum `f` value.
                    node = openList.pop();
                    node.closed = true;

                    // if reached the end position, construct the path and return it
                    if (node === endNode) {
                        return Util.backtrace(endNode);
                    }

                    // get neigbours of the current node
                    neighbors = grid.getNeighbors(node, allowDiagonal, dontCrossCorners);
                    for (i = 0, l = neighbors.length; i < l; ++i) {
                        neighbor = neighbors[i];

                        if (neighbor.closed) {
                            continue;
                        }

                        x = neighbor.x;
                        y = neighbor.y;
                        z = neighbor.z;

                        // get the distance between current node and the neighbor
                        // and calculate the next g score
                        ng = node.g + ((x - node.x === 0 || y - node.y === 0 || z - node.z === 0) ? 1 : SQRT2);

                        // check if the neighbor has not been inspected yet, or
                        // can be reached with smaller cost from the current node
                        if (!neighbor.opened || ng < neighbor.g) {
                            neighbor.g = ng;
                            neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY), abs(z - endZ));
                            neighbor.f = neighbor.g + neighbor.h;
                            neighbor.parent = node;

                            if (!neighbor.opened) {
                                openList.push(neighbor);
                                neighbor.opened = true;
                            } else {
                                // the neighbor can be reached with smaller cost.
                                // Since its f value has been updated, we have to
                                // update its position in the open list
                                openList.updateItem(neighbor);
                            }
                        }
                    } // end for each neighbor
                } // end while not open list empty

                // fail to find the path
                return [];
            };

            module.exports = AStarFinder;

        }, { "../core/Heuristic": 5, "../core/Util": 7, "heap": 1 }], 9: [function (require, module, exports) {
            var AStarFinder = require('./AStarFinder');

            /**
             * Best-First-Search path-finder.
             * @constructor
             * @extends AStarFinder
             * @param {object} opt
             * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
             * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners.
             * @param {function} opt.heuristic Heuristic function to estimate the distance
             *     (defaults to manhattan).
             */
            function BestFirstFinder(opt) {
                AStarFinder.call(this, opt);

                var orig = this.heuristic;
                this.heuristic = function (dx, dy, dz) {
                    return orig(dx, dy, dz) * 1000000;
                };
            }

            BestFirstFinder.prototype = new AStarFinder();
            BestFirstFinder.prototype.constructor = BestFirstFinder;

            module.exports = BestFirstFinder;

        }, { "./AStarFinder": 8 }], 10: [function (require, module, exports) {
            var Heap = require('heap');
            var Util = require('../core/Util');
            var Heuristic = require('../core/Heuristic');

            /**
             * A* path-finder.
             * based upon https://github.com/bgrins/javascript-astar
             * @constructor
             * @param {object} opt
             * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
             * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners.
             * @param {function} opt.heuristic Heuristic function to estimate the distance
             *     (defaults to manhattan).
             * @param {integer} opt.weight Weight to apply to the heuristic to allow for suboptimal paths, 
             *     in order to speed up the search.
             */
            function BiAStarFinder(opt) {
                opt = opt || {};
                this.allowDiagonal = opt.allowDiagonal;
                this.dontCrossCorners = opt.dontCrossCorners;
                this.heuristic = opt.heuristic || Heuristic.manhattan;
                this.weight = opt.weight || 1;
            }

            /**
             * Find and return the the path.
             * @return {Array.<[number, number]>} The path, including both start and
             *     end positions.
             */
            BiAStarFinder.prototype.findPath = function (startX, startY, startZ, endX, endY, endZ, grid) {
                var cmp = function (nodeA, nodeB) {
                    return nodeA.f - nodeB.f;
                },
                    startOpenList = new Heap(cmp),
                    endOpenList = new Heap(cmp),
                    startNode = grid.getNodeAt(startX, startY),
                    endNode = grid.getNodeAt(endX, endY),
                    heuristic = this.heuristic,
                    allowDiagonal = this.allowDiagonal,
                    dontCrossCorners = this.dontCrossCorners,
                    weight = this.weight,
                    abs = Math.abs, SQRT2 = Math.SQRT2,
                    node, neighbors, neighbor, i, l, x, y, ng, z,
                    BY_START = 1, BY_END = 2;

                // set the `g` and `f` value of the start node to be 0
                // and push it into the start open list
                startNode.g = 0;
                startNode.f = 0;
                startOpenList.push(startNode);
                startNode.opened = BY_START;

                // set the `g` and `f` value of the end node to be 0
                // and push it into the open open list
                endNode.g = 0;
                endNode.f = 0;
                endOpenList.push(endNode);
                endNode.opened = BY_END;

                // while both the open lists are not empty
                while (!startOpenList.empty() && !endOpenList.empty()) {

                    // pop the position of start node which has the minimum `f` value.
                    node = startOpenList.pop();
                    node.closed = true;

                    // get neigbours of the current node
                    neighbors = grid.getNeighbors(node, allowDiagonal, dontCrossCorners);
                    for (i = 0, l = neighbors.length; i < l; ++i) {
                        neighbor = neighbors[i];

                        if (neighbor.closed) {
                            continue;
                        }
                        if (neighbor.opened === BY_END) {
                            return Util.biBacktrace(node, neighbor);
                        }

                        x = neighbor.x;
                        y = neighbor.y;
                        z = neighbor.z;

                        // get the distance between current node and the neighbor
                        // and calculate the next g score
                        ng = node.g + ((x - node.x === 0 || y - node.y === 0 || z - node.z === 0) ? 1 : SQRT2);

                        // check if the neighbor has not been inspected yet, or
                        // can be reached with smaller cost from the current node
                        if (!neighbor.opened || ng < neighbor.g) {
                            neighbor.g = ng;
                            neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY), abs(z - endZ));
                            neighbor.f = neighbor.g + neighbor.h;
                            neighbor.parent = node;

                            if (!neighbor.opened) {
                                startOpenList.push(neighbor);
                                neighbor.opened = BY_START;
                            } else {
                                // the neighbor can be reached with smaller cost.
                                // Since its f value has been updated, we have to
                                // update its position in the open list
                                startOpenList.updateItem(neighbor);
                            }
                        }
                    } // end for each neighbor


                    // pop the position of end node which has the minimum `f` value.
                    node = endOpenList.pop();
                    node.closed = true;

                    // get neigbours of the current node
                    neighbors = grid.getNeighbors(node, allowDiagonal, dontCrossCorners);
                    for (i = 0, l = neighbors.length; i < l; ++i) {
                        neighbor = neighbors[i];

                        if (neighbor.closed) {
                            continue;
                        }
                        if (neighbor.opened === BY_START) {
                            return Util.biBacktrace(neighbor, node);
                        }

                        x = neighbor.x;
                        y = neighbor.y;
                        z = neighbor.z;

                        // get the distance between current node and the neighbor
                        // and calculate the next g score
                        ng = node.g + ((x - node.x === 0 || y - node.y === 0 || z - node.z === 0) ? 1 : SQRT2);

                        // check if the neighbor has not been inspected yet, or
                        // can be reached with smaller cost from the current node
                        if (!neighbor.opened || ng < neighbor.g) {
                            neighbor.g = ng;
                            neighbor.h = neighbor.h || weight * heuristic(abs(x - startX), abs(y - startY), abs(z - startZ));
                            neighbor.f = neighbor.g + neighbor.h;
                            neighbor.parent = node;

                            if (!neighbor.opened) {
                                endOpenList.push(neighbor);
                                neighbor.opened = BY_END;
                            } else {
                                // the neighbor can be reached with smaller cost.
                                // Since its f value has been updated, we have to
                                // update its position in the open list
                                endOpenList.updateItem(neighbor);
                            }
                        }
                    } // end for each neighbor
                } // end while not open list empty

                // fail to find the path
                return [];
            };

            module.exports = BiAStarFinder;

        }, { "../core/Heuristic": 5, "../core/Util": 7, "heap": 1 }], 11: [function (require, module, exports) {
            var BiAStarFinder = require('./BiAStarFinder');

            /**
             * Bi-direcitional Best-First-Search path-finder.
             * @constructor
             * @extends BiAStarFinder
             * @param {object} opt
             * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
             * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners.
             * @param {function} opt.heuristic Heuristic function to estimate the distance
             *     (defaults to manhattan).
             */
            function BiBestFirstFinder(opt) {
                BiAStarFinder.call(this, opt);

                var orig = this.heuristic;
                this.heuristic = function (dx, dy, dz) {
                    return orig(dx, dy, dz) * 1000000;
                };
            }

            BiBestFirstFinder.prototype = new BiAStarFinder();
            BiBestFirstFinder.prototype.constructor = BiBestFirstFinder;

            module.exports = BiBestFirstFinder;

        }, { "./BiAStarFinder": 10 }], 12: [function (require, module, exports) {
            var Util = require('../core/Util');

            /**
             * Bi-directional Breadth-First-Search path finder.
             * @constructor
             * @param {object} opt
             * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
             * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners.
             */
            function BiBreadthFirstFinder(opt) {
                opt = opt || {};
                this.allowDiagonal = opt.allowDiagonal;
                this.dontCrossCorners = opt.dontCrossCorners;
            }


            /**
             * Find and return the the path.
             * @return {Array.<[number, number]>} The path, including both start and
             *     end positions.
             */
            BiBreadthFirstFinder.prototype.findPath = function (startX, startY, startZ, endX, endY, endZ, grid) {
                var startNode = grid.getNodeAt(startX, startY, startZ),
                    endNode = grid.getNodeAt(endX, endY, endZ),
                    startOpenList = [], endOpenList = [],
                    neighbors, neighbor, node,
                    allowDiagonal = this.allowDiagonal,
                    dontCrossCorners = this.dontCrossCorners,
                    BY_START = 0, BY_END = 1,
                    i, l;

                // push the start and end nodes into the queues
                startOpenList.push(startNode);
                startNode.opened = true;
                startNode.by = BY_START;

                endOpenList.push(endNode);
                endNode.opened = true;
                endNode.by = BY_END;

                // while both the queues are not empty
                while (startOpenList.length && endOpenList.length) {

                    // expand start open list

                    node = startOpenList.shift();
                    node.closed = true;

                    neighbors = grid.getNeighbors(node, allowDiagonal, dontCrossCorners);
                    for (i = 0, l = neighbors.length; i < l; ++i) {
                        neighbor = neighbors[i];

                        if (neighbor.closed) {
                            continue;
                        }
                        if (neighbor.opened) {
                            // if this node has been inspected by the reversed search,
                            // then a path is found.
                            if (neighbor.by === BY_END) {
                                return Util.biBacktrace(node, neighbor);
                            }
                            continue;
                        }
                        startOpenList.push(neighbor);
                        neighbor.parent = node;
                        neighbor.opened = true;
                        neighbor.by = BY_START;
                    }

                    // expand end open list

                    node = endOpenList.shift();
                    node.closed = true;

                    neighbors = grid.getNeighbors(node, allowDiagonal, dontCrossCorners);
                    for (i = 0, l = neighbors.length; i < l; ++i) {
                        neighbor = neighbors[i];

                        if (neighbor.closed) {
                            continue;
                        }
                        if (neighbor.opened) {
                            if (neighbor.by === BY_START) {
                                return Util.biBacktrace(neighbor, node);
                            }
                            continue;
                        }
                        endOpenList.push(neighbor);
                        neighbor.parent = node;
                        neighbor.opened = true;
                        neighbor.by = BY_END;
                    }
                }

                // fail to find the path
                return [];
            };

            module.exports = BiBreadthFirstFinder;

        }, { "../core/Util": 7 }], 13: [function (require, module, exports) {
            var BiAStarFinder = require('./BiAStarFinder');

            /**
             * Bi-directional Dijkstra path-finder.
             * @constructor
             * @extends BiAStarFinder
             * @param {object} opt
             * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
             * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners.
             */
            function BiDijkstraFinder(opt) {
                BiAStarFinder.call(this, opt);
                this.heuristic = function (dx, dy, dz) {
                    return 0;
                };
            }

            BiDijkstraFinder.prototype = new BiAStarFinder();
            BiDijkstraFinder.prototype.constructor = BiDijkstraFinder;

            module.exports = BiDijkstraFinder;

        }, { "./BiAStarFinder": 10 }], 14: [function (require, module, exports) {
            var Util = require('../core/Util');

            /**
             * Breadth-First-Search path finder.
             * @constructor
             * @param {object} opt
             * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
             * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners.
             */
            function BreadthFirstFinder(opt) {
                opt = opt || {};
                this.allowDiagonal = opt.allowDiagonal;
                this.dontCrossCorners = opt.dontCrossCorners;
            }

            /**
             * Find and return the the path.
             * @return {Array.<[number, number]>} The path, including both start and
             *     end positions.
             */
            BreadthFirstFinder.prototype.findPath = function (startX, startY, startZ, endX, endY, endZ, grid) {
                var openList = [],
                    allowDiagonal = this.allowDiagonal,
                    dontCrossCorners = this.dontCrossCorners,
                    startNode = grid.getNodeAt(startX, startY, startZ),
                    endNode = grid.getNodeAt(endX, endY, endZ),
                    neighbors, neighbor, node, i, l;

                // push the start pos into the queue
                openList.push(startNode);
                startNode.opened = true;

                // while the queue is not empty
                while (openList.length) {
                    // take the front node from the queue
                    node = openList.shift();
                    node.closed = true;

                    // reached the end position
                    if (node === endNode) {
                        return Util.backtrace(endNode);
                    }

                    neighbors = grid.getNeighbors(node, allowDiagonal, dontCrossCorners);
                    for (i = 0, l = neighbors.length; i < l; ++i) {
                        neighbor = neighbors[i];

                        // skip this neighbor if it has been inspected before
                        if (neighbor.closed || neighbor.opened) {
                            continue;
                        }

                        openList.push(neighbor);
                        neighbor.opened = true;
                        neighbor.parent = node;
                    }
                }

                // fail to find the path
                return [];
            };

            module.exports = BreadthFirstFinder;

        }, { "../core/Util": 7 }], 15: [function (require, module, exports) {
            var AStarFinder = require('./AStarFinder');

            /**
             * Dijkstra path-finder.
             * @constructor
             * @extends AStarFinder
             * @param {object} opt
             * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
             * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners.
             */
            function DijkstraFinder(opt) {
                AStarFinder.call(this, opt);
                this.heuristic = function (dx, dy, dz) {
                    return 0;
                };
            }

            DijkstraFinder.prototype = new AStarFinder();
            DijkstraFinder.prototype.constructor = DijkstraFinder;

            module.exports = DijkstraFinder;

        }, { "./AStarFinder": 8 }], 16: [function (require, module, exports) {
            var Util = require('../core/Util');
            var Heuristic = require('../core/Heuristic');
            var Node = require('../core/Node');

            /**
             * Iterative Deeping A Star (IDA*) path-finder.
             *
             * Recursion based on:
             *   http://www.apl.jhu.edu/~hall/AI-Programming/IDA-Star.html
             *
             * Path retracing based on:
             *  V. Nageshwara Rao, Vipin Kumar and K. Ramesh
             *  "A Parallel Implementation of Iterative-Deeping-A*", January 1987.
             *  ftp://ftp.cs.utexas.edu/.snapshot/hourly.1/pub/AI-Lab/tech-reports/UT-AI-TR-87-46.pdf
             *
             * @author Gerard Meier (www.gerardmeier.com)
             *
             * @constructor
             * @param {object} opt
             * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
             * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners.
             * @param {function} opt.heuristic Heuristic function to estimate the distance
             *     (defaults to manhattan).
             * @param {integer} opt.weight Weight to apply to the heuristic to allow for suboptimal paths,
             *     in order to speed up the search.
             * @param {object} opt.trackRecursion Whether to track recursion for statistical purposes.
             * @param {object} opt.timeLimit Maximum execution time. Use <= 0 for infinite.
             */

            function IDAStarFinder(opt) {
                opt = opt || {};
                this.allowDiagonal = opt.allowDiagonal;
                this.dontCrossCorners = opt.dontCrossCorners;
                this.heuristic = opt.heuristic || Heuristic.manhattan;
                this.weight = opt.weight || 1;
                this.trackRecursion = opt.trackRecursion || false;
                this.timeLimit = opt.timeLimit || Infinity; // Default: no time limit.
            }

            /**
             * Find and return the the path. When an empty array is returned, either
             * no path is possible, or the maximum execution time is reached.
             *
             * @return {Array.<[number, number]>} The path, including both start and
             *     end positions.
             */
            IDAStarFinder.prototype.findPath = function (startX, startY, startZ, endX, endY, endZ, grid) {
                // Used for statistics:
                var nodesVisited = 0;

                // Execution time limitation:
                var startTime = new Date().getTime();

                // Heuristic helper:
                var h = function (a, b) {
                    return this.heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y), Math.abs(b.z - a.z));
                }.bind(this);

                // Step cost from a to b:
                var cost = function (a, b) {
                    return (a.x === b.x || a.y === b.y || a.z === b.z) ? 1 : Math.SQRT2;
                };

                /**
                 * IDA* search implementation.
                 *
                 * @param {Node} The node currently expanding from.
                 * @param {number} Cost to reach the given node.
                 * @param {number} Maximum search depth (cut-off value).
                 * @param {{Array.<[number, number]>}} The found route.
                 * @param {number} Recursion depth.
                 *
                 * @return {Object} either a number with the new optimal cut-off depth,
                 * or a valid node instance, in which case a path was found.
                 */
                var search = function (node, g, cutoff, route, depth) {
                    nodesVisited++;

                    // Enforce timelimit:
                    if (this.timeLimit > 0 && new Date().getTime() - startTime > this.timeLimit * 1000) {
                        // Enforced as "path-not-found".
                        return Infinity;
                    }

                    var f = g + h(node, end) * this.weight;

                    // We've searched too deep for this iteration.
                    if (f > cutoff) {
                        return f;
                    }

                    if (node == end) {
                        route[depth] = [node.x, node.y, node.z];
                        return node;
                    }

                    var min, t, k, neighbour;

                    var neighbours = grid.getNeighbors(node, this.allowDiagonal, this.dontCrossCorners);

                    // Sort the neighbours, gives nicer paths. But, this deviates
                    // from the original algorithm - so I left it out.
                    //neighbours.sort(function(a, b){
                    //    return h(a, end) - h(b, end);
                    //});

                    for (k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {

                        if (this.trackRecursion) {
                            // Retain a copy for visualisation. Due to recursion, this
                            // node may be part of other paths too.
                            neighbour.retainCount = neighbour.retainCount + 1 || 1;

                            if (neighbour.tested !== true) {
                                neighbour.tested = true;
                            }
                        }

                        t = search(neighbour, g + cost(node, neighbour), cutoff, route, depth + 1);

                        if (t instanceof Node) {
                            route[depth] = [node.x, node.y, node.z];

                            // For a typical A* linked list, this would work:
                            // neighbour.parent = node;
                            return t;
                        }

                        // Decrement count, then determine whether it's actually closed.
                        if (this.trackRecursion && (--neighbour.retainCount) === 0) {
                            neighbour.tested = false;
                        }

                        if (t < min) {
                            min = t;
                        }
                    }

                    return min;

                }.bind(this);

                // Node instance lookups:
                var start = grid.getNodeAt(startX, startY, startZ);
                var end = grid.getNodeAt(endX, endY, endZ);

                // Initial search depth, given the typical heuristic contraints,
                // there should be no cheaper route possible.
                var cutOff = h(start, end);

                var j, route, t;

                // With an overflow protection.
                for (j = 0; true; ++j) {
                    //console.log("Iteration: " + j + ", search cut-off value: " + cutOff + ", nodes visited thus far: " + nodesVisited + ".");

                    route = [];

                    // Search till cut-off depth:
                    t = search(start, 0, cutOff, route, 0);

                    // Route not possible, or not found in time limit.
                    if (t === Infinity) {
                        return [];
                    }

                    // If t is a node, it's also the end node. Route is now
                    // populated with a valid path to the end node.
                    if (t instanceof Node) {
                        //console.log("Finished at iteration: " + j + ", search cut-off value: " + cutOff + ", nodes visited: " + nodesVisited + ".");
                        return route;
                    }

                    // Try again, this time with a deeper cut-off. The t score
                    // is the closest we got to the end node.
                    cutOff = t;
                }

                // This _should_ never to be reached.
                return [];
            };

            module.exports = IDAStarFinder;

        }, { "../core/Heuristic": 5, "../core/Node": 6, "../core/Util": 7 }], 17: [function (require, module, exports) {
            /**
             * @author aniero / https://github.com/aniero
             */
            var Heap = require('heap');
            var Util = require('../core/Util');
            var Heuristic = require('../core/Heuristic');

            /**
             * Path finder using the Jump Point Search algorithm
             * @param {object} opt
             * @param {function} opt.heuristic Heuristic function to estimate the distance
             *     (defaults to manhattan).
             */
            function JumpPointFinder(opt) {
                opt = opt || {};
                this.heuristic = opt.heuristic || Heuristic.manhattan;
                this.trackJumpRecursion = opt.trackJumpRecursion || false;
            }

            /**
             * Find and return the path.
             * @return {Array.<[number, number]>} The path, including both start and
             *     end positions.
             */
            JumpPointFinder.prototype.findPath = function (startX, startY, startZ, endX, endY, endZ, grid) {
                var openList = this.openList = new Heap(function (nodeA, nodeB) {
                    return nodeA.f - nodeB.f;
                }),
                    startNode = this.startNode = grid.getNodeAt(startX, startY, startZ),
                    endNode = this.endNode = grid.getNodeAt(endX, endY, endZ), node;

                this.grid = grid;


                // set the `g` and `f` value of the start node to be 0
                startNode.g = 0;
                startNode.f = 0;

                // push the start node into the open list
                openList.push(startNode);
                startNode.opened = true;

                // while the open list is not empty
                while (!openList.empty()) {
                    // pop the position of node which has the minimum `f` value.
                    node = openList.pop();
                    node.closed = true;

                    if (node === endNode) {
                        return Util.backtrace(endNode);
                    }

                    this._identifySuccessors(node);
                }

                // fail to find the path
                return [];
            };

            /**
             * Identify successors for the given node. Runs a jump point search in the
             * direction of each available neighbor, adding any points found to the open
             * list.
             * @protected
             */
            JumpPointFinder.prototype._identifySuccessors = function (node) {
                var grid = this.grid,
                    heuristic = this.heuristic,
                    openList = this.openList,
                    endX = this.endNode.x,
                    endY = this.endNode.y,
                    endZ = this.endNode.z
                neighbors, neighbor,
                    jumpPoint, i, l,
                    x = node.x, y = node.y, z = node.z
                jx, jy, dx, dy, d, ng, jumpNode, dz, jz
                abs = Math.abs, max = Math.max;

                neighbors = this._findNeighbors(node);
                for (i = 0, l = neighbors.length; i < l; ++i) {
                    neighbor = neighbors[i];
                    jumpPoint = this._jump(neighbor[0], neighbor[1], x, y, z);
                    if (jumpPoint) {

                        jx = jumpPoint[0];
                        jy = jumpPoint[1];
                        jz = jumpPoint[2]
                        jumpNode = grid.getNodeAt(jx, jy, jz);

                        if (jumpNode.closed) {
                            continue;
                        }

                        // include distance, as parent may not be immediately adjacent:
                        d = Heuristic.euclidean(abs(jx - x), abs(jy - y), abs(jz - z));
                        ng = node.g + d; // next `g` value

                        if (!jumpNode.opened || ng < jumpNode.g) {
                            jumpNode.g = ng;
                            jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY), abs(jz - endZ));
                            jumpNode.f = jumpNode.g + jumpNode.h;
                            jumpNode.parent = node;

                            if (!jumpNode.opened) {
                                openList.push(jumpNode);
                                jumpNode.opened = true;
                            } else {
                                openList.updateItem(jumpNode);
                            }
                        }
                    }
                }
            };

            /**
             * Search recursively in the direction (parent -> child), stopping only when a
             * jump point is found.
             * @protected
             * @return {Array.<[number, number]>} The x, y coordinate of the jump point
             *     found, or null if not found
             */
            JumpPointFinder.prototype._jump = function (x, y, z, px, py, pz) {
                var grid = this.grid,
                    dx = x - px, dy = y - py, jx, jy;
                dz = z - pz, jz;

                if (!grid.isWalkableAt(x, y, z)) {
                    return null;
                }

                if (this.trackJumpRecursion === true) {
                    grid.getNodeAt(x, y, z).tested = true;
                }

                if (grid.getNodeAt(x, y, z) === this.endNode) {
                    return [x, y, z];
                }

                // check for forced neighbors
                // along the diagonal
                if (dx !== 0 && dy !== 0) {
                    if ((grid.isWalkableAt(x - dx, y + dy, z) && !grid.isWalkableAt(x - dx, y, z)) ||
                        (grid.isWalkableAt(x + dx, y - dy, z) && !grid.isWalkableAt(x, y - dy, z))) {
                        return [x, y, z];
                    }
                }
                // horizontally/vertically
                else {
                    if (dx !== 0) { // moving along x
                        if ((grid.isWalkableAt(x + dx, y + 1, z) && !grid.isWalkableAt(x, y + 1, z)) ||
                            (grid.isWalkableAt(x + dx, y - 1, z) && !grid.isWalkableAt(x, y - 1, z))) {
                            return [x, y, z];
                        }
                    }
                    else {
                        if ((grid.isWalkableAt(x + 1, y + dy, z) && !grid.isWalkableAt(x + 1, y, z)) ||
                            (grid.isWalkableAt(x - 1, y + dy, z) && !grid.isWalkableAt(x - 1, y, z))) {
                            return [x, y, z];
                        }
                    }
                }
                if (dz !== 0) {
                    jz = his._jump(x, y, z + dz, x, y, z);
                    if (jz) return [x, y, z];
                }
                // when moving diagonally, must check for vertical/horizontal jump points
                if (dx !== 0 && dy !== 0) {
                    jx = this._jump(x + dx, y, z, x, y, z);
                    jy = this._jump(x, y + dy, z, x, y, z);
                    if (jx || jy) {
                        return [x, y, z];
                    }
                }

                // moving diagonally, must make sure one of the vertical/horizontal
                // neighbors is open to allow the path
                if (grid.isWalkableAt(x + dx, y, z) || grid.isWalkableAt(x, y + dy, z)) {
                    return this._jump(x + dx, y + dy, z, x, y, z);
                } else {
                    return null;
                }
            };

            /**
             * Find the neighbors for the given node. If the node has a parent,
             * prune the neighbors based on the jump point search algorithm, otherwise
             * return all available neighbors.
             * @return {Array.<[number, number]>} The neighbors found.
             */
            JumpPointFinder.prototype._findNeighbors = function (node) {
                var parent = node.parent,
                    x = node.x, y = node.y, z = node.z,
                    grid = this.grid,
                    px, py, nx, ny, dx, dy, pz, nz, dz
                neighbors = [], neighborNodes, neighborNode, i, l;

                // directed pruning: can ignore most neighbors, unless forced.

                if (parent) {
                    px = parent.x;
                    py = parent.y;
                    pz = parent.z;
                    // get the normalized direction of travel
                    dx = (x - px) / Math.max(Math.abs(x - px), 1);
                    dy = (y - py) / Math.max(Math.abs(y - py), 1);
                    dz = (z - pz) / Math.max(Math.abs(z - pz), 1);

                    //search up/down
                    if (dz !== 0) {
                        if (grid.isWalkableAt(x, y, z + dz)) {
                            if (grid.isWalkableAt(x, y, z + dz)) {
                                neighbors.push([x + dx, y + dy, z + dz]);
                            }
                            if (!grid.isWalkableAt(x, y, z + 1)) {
                                neighbors.push([x + dx, y + dy, z + 1]);
                            }
                            if (!grid.isWalkableAt(x, y, z - 1)) {
                                neighbors.push([x + dx, y + dy, z - 1]);
                            }
                        }
                    }
                    // search diagonally
                    else if (dx !== 0 && dy !== 0) {
                        if (grid.isWalkableAt(x, y + dy, z)) {
                            neighbors.push([x, y + dy, z]);
                        }
                        if (grid.isWalkableAt(x + dx, y, z)) {
                            neighbors.push([x + dx, y, z]);
                        }
                        if (grid.isWalkableAt(x, y + dy, z) || grid.isWalkableAt(x + dx, y, z)) {
                            neighbors.push([x + dx, y + dy, z]);
                        }
                        if (!grid.isWalkableAt(x - dx, y, z) && grid.isWalkableAt(x, y + dy, z)) {
                            neighbors.push([x - dx, y + dy, z]);
                        }
                        if (!grid.isWalkableAt(x, y - dy, z) && grid.isWalkableAt(x + dx, y, z)) {
                            neighbors.push([x + dx, y - dy, z]);
                        }
                    }
                    // search horizontally/vertically
                    else {
                        if (dx === 0) {
                            if (grid.isWalkableAt(x, y + dy, z)) {
                                if (grid.isWalkableAt(x, y + dy, z)) {
                                    neighbors.push([x, y + dy, z]);
                                }
                                if (!grid.isWalkableAt(x + 1, y, z)) {
                                    neighbors.push([x + 1, y + dy, z]);
                                }
                                if (!grid.isWalkableAt(x - 1, y, z)) {
                                    neighbors.push([x - 1, y + dy, z]);
                                }
                            }
                        }
                        else {
                            if (grid.isWalkableAt(x + dx, y, z)) {
                                if (grid.isWalkableAt(x + dx, y, z)) {
                                    neighbors.push([x + dx, y, z]);
                                }
                                if (!grid.isWalkableAt(x, y + 1, z)) {
                                    neighbors.push([x + dx, y + 1, z]);
                                }
                                if (!grid.isWalkableAt(x, y - 1, z)) {
                                    neighbors.push([x + dx, y - 1, z]);
                                }
                            }
                        }
                    }
                }
                // return all neighbors
                else {
                    neighborNodes = grid.getNeighbors(node, true);
                    for (i = 0, l = neighborNodes.length; i < l; ++i) {
                        neighborNode = neighborNodes[i];
                        neighbors.push([neighborNode.x, neighborNode.y, neighborNode.z]);
                    }
                }

                return neighbors;
            };

            module.exports = JumpPointFinder;

        }, { "../core/Heuristic": 5, "../core/Util": 7, "heap": 1 }]
    }, {}, [3])(3);
});